[
    {
        "id": "e817c53a81aff0e0",
        "type": "tab",
        "label": "IoT Final Project",
        "disabled": false,
        "info": ""
    },
    {
        "id": "a5d3967d08db715e",
        "type": "comment",
        "z": "e817c53a81aff0e0",
        "name": "WARNING: please check you have started this container with a volume that is mounted to /data\\n otherwise any flow changes are lost when you redeploy or upgrade the container\\n (e.g. upgrade to a more recent node-red docker image).\\n  If you are using named volumes you can ignore this warning.\\n Double click or see info side panel to learn how to start Node-RED in Docker to save your work",
        "info": "\nTo start docker with a bind mount volume (-v option), for example:\n\n```\ndocker run -it -p 1880:1880 -v /home/user/node_red_data:/data --name mynodered nodered/node-red\n```\n\nwhere `/home/user/node_red_data` is a directory on your host machine where you want to store your flows.\n\nIf you do not do this then you can experiment and redploy flows, but if you restart or upgrade the container the flows will be disconnected and lost. \n\nThey will still exist in a hidden data volume, which can be recovered using standard docker techniques, but that is much more complex than just starting with a named volume as described above.",
        "x": 350,
        "y": 80,
        "wires": []
    },
    {
        "id": "36a2f213c3f9ad78",
        "type": "mqtt in",
        "z": "e817c53a81aff0e0",
        "name": "MQTT from ESP32 (Reed)",
        "topic": "door_status",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "83232c1e0408fa13",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 330,
        "y": 460,
        "wires": [
            [
                "8317e7dd9abaaf51"
            ]
        ]
    },
    {
        "id": "8317e7dd9abaaf51",
        "type": "function",
        "z": "e817c53a81aff0e0",
        "name": "function 1",
        "func": "// 1. Handle incoming data (Parse if it's a string, use as-is if it's an object)\nlet data = msg.payload;\n\n// Safety check: sometimes MQTT nodes pass data as a JSON string, not an object.\nif (typeof data === 'string') {\n    try {\n        data = JSON.parse(data);\n    } catch (e) {\n        node.warn(\"Input was not valid JSON\");\n        return null;\n    }\n}\n\n// 2. Extract variables from the incoming JSON\n// Use specific names so we don't overwrite them later\nlet inputStatus = data.status ? data.status.toLowerCase() : \"\";\nlet inputDoorID = data.door_id;\n\n// 3. Validation: Stop if door_id is missing\nif (!inputDoorID) {\n    node.warn(\"Missing door_id in payload\");\n    return null;\n}\n\n// 4. Convert Status to Integer\nlet statusInt;\nif (inputStatus === \"open\") {\n    statusInt = 1;\n} else if (inputStatus === \"closed\") {\n    statusInt = 0;\n} else {\n    node.warn(`Invalid status: ${inputStatus}`);\n    return null;\n}\n\n// 5. Construct the InfluxDB Message\nmsg.measurement = \"door_status\";\nmsg.tags = {\n    door_id: inputDoorID\n};\nmsg.payload = {\n    status: statusInt\n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 460,
        "wires": [
            [
                "8a84c587d9df11ee"
            ]
        ]
    },
    {
        "id": "8a84c587d9df11ee",
        "type": "influxdb out",
        "z": "e817c53a81aff0e0",
        "influxdb": "b99fd905dd34feb9",
        "name": "influx_door_status",
        "measurement": "",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "docs",
        "bucket": "home",
        "x": 830,
        "y": 460,
        "wires": []
    },
    {
        "id": "032cf6f5f2eec990",
        "type": "http in",
        "z": "e817c53a81aff0e0",
        "name": "HTTP Control Get",
        "url": "/control",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 310,
        "y": 320,
        "wires": [
            [
                "4714305f19f4759d"
            ]
        ]
    },
    {
        "id": "f2b908d894a50849",
        "type": "http response",
        "z": "e817c53a81aff0e0",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1190,
        "y": 360,
        "wires": []
    },
    {
        "id": "5c9f5aef3c86ed57",
        "type": "function",
        "z": "e817c53a81aff0e0",
        "name": "function 2",
        "func": "// Safety check: no data returned from InfluxDB\nif (!msg.payload || msg.payload.length === 0) {\n    msg.statusCode = 404;\n    msg.payload = {\n        status: null,\n        message: \"No door status has been recorded yet\"\n    };\n    return msg;\n}\n\n// Extract latest door status from Influx result\nconst status = msg.payload[0]._value;\n\n// Build HTTP response\nmsg.statusCode = 200;\nmsg.payload = {\n    status: status,\n    message: status === 1 ? \"Door is open\" : \"Door is closed\"\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 360,
        "wires": [
            [
                "f2b908d894a50849"
            ]
        ]
    },
    {
        "id": "a29b1adeadf5d6f1",
        "type": "http in",
        "z": "e817c53a81aff0e0",
        "name": "HTTP Control Post",
        "url": "/control",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 310,
        "y": 600,
        "wires": [
            [
                "084fd0877751c813"
            ]
        ]
    },
    {
        "id": "65ff29db8076d638",
        "type": "http response",
        "z": "e817c53a81aff0e0",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 1120,
        "y": 700,
        "wires": []
    },
    {
        "id": "022d67b064290496",
        "type": "mqtt out",
        "z": "e817c53a81aff0e0",
        "name": "MQTT to ESP32 (Control)",
        "topic": "door_1/control",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "83232c1e0408fa13",
        "x": 1630,
        "y": 840,
        "wires": []
    },
    {
        "id": "f6c6086a0959513b",
        "type": "influxdb in",
        "z": "e817c53a81aff0e0",
        "influxdb": "b99fd905dd34feb9",
        "name": "",
        "query": "from(bucket: \"home\")\n  |> range(start: -7d)\n  |> filter(fn: (r) => r._measurement == \"door_status\")\n  |> filter(fn: (r) => r._field == \"status\")\n  |> last()",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "docs",
        "x": 860,
        "y": 360,
        "wires": [
            [
                "5c9f5aef3c86ed57",
                "4dd49362f3b856bb"
            ]
        ]
    },
    {
        "id": "4dd49362f3b856bb",
        "type": "debug",
        "z": "e817c53a81aff0e0",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 300,
        "wires": []
    },
    {
        "id": "4714305f19f4759d",
        "type": "function",
        "z": "e817c53a81aff0e0",
        "name": "Bearer API Key Auth",
        "func": "// 1. Read Authorization header\nconst authHeader = msg.req.headers.authorization;\n\n// 2. Missing header\nif (!authHeader) {\n    msg.statusCode = 401;\n    msg.payload = { error: \"Missing Authorization header\" };\n    msg._authFailed = true;\n    return msg;\n}\n\n\n// 3. Must be Bearer <token>\nconst parts = authHeader.split(\" \");\nif (parts.length !== 2 || parts[0] !== \"Bearer\") {\n    msg.statusCode = 400;\n    msg.payload = { error: \"Invalid Authorization format\" };\n    return msg;\n}\n\n// 4. Extract token\nconst token = parts[1];\n\n// 5. Validate against API key\nconst API_KEY = env.get(\"API_KEY\");   // recommended\n\nif (!API_KEY) {\n    msg.statusCode = 500;\n    msg.payload = { error: \"API key not configured on server\" };\n    return msg;\n}\n\nif (token !== API_KEY) {\n    msg.statusCode = 403;\n    msg.payload = { error: \"Invalid API key\" };\n    msg._authFailed = true;\n    return msg;\n\n}\n\n// 6. Auth success → continue\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 320,
        "wires": [
            [
                "1a647dd990a61909"
            ]
        ]
    },
    {
        "id": "084fd0877751c813",
        "type": "function",
        "z": "e817c53a81aff0e0",
        "name": "Bearer API Key Auth",
        "func": "// 1. Read Authorization header\nconst authHeader = msg.req.headers.authorization;\n\n// 2. Missing header\nif (!authHeader) {\n    msg.statusCode = 401;\n    msg.payload = { error: \"Missing Authorization header\" };\n    msg._authFailed = true;\n    return msg;\n}\n\n\n// 3. Must be Bearer <token>\nconst parts = authHeader.split(\" \");\nif (parts.length !== 2 || parts[0] !== \"Bearer\") {\n    msg.statusCode = 400;\n    msg.payload = { error: \"Invalid Authorization format\" };\n    return msg;\n}\n\n// 4. Extract token\nconst token = parts[1];\n\n// 5. Validate against API key\nconst API_KEY = env.get(\"API_KEY\");   // recommended\n\nif (!API_KEY) {\n    msg.statusCode = 500;\n    msg.payload = { error: \"API key not configured on server\" };\n    return msg;\n}\n\nif (token !== API_KEY) {\n    msg.statusCode = 403;\n    msg.payload = { error: \"Invalid API key\" };\n    msg._authFailed = true;\n    return msg;\n}\n\n// 6. Auth success → continue\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 600,
        "wires": [
            [
                "9905b0f206c6d209"
            ]
        ]
    },
    {
        "id": "1a647dd990a61909",
        "type": "switch",
        "z": "e817c53a81aff0e0",
        "name": "",
        "property": "_authFailed",
        "propertyType": "msg",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 690,
        "y": 320,
        "wires": [
            [
                "2a2c3e6a022d6303"
            ],
            [
                "f6c6086a0959513b"
            ]
        ]
    },
    {
        "id": "9905b0f206c6d209",
        "type": "switch",
        "z": "e817c53a81aff0e0",
        "name": "",
        "property": "_authFailed",
        "propertyType": "msg",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 690,
        "y": 600,
        "wires": [
            [
                "cc777a9dc8f4a1e9"
            ],
            [
                "65ff29db8076d638",
                "b617697f6a501d22"
            ]
        ]
    },
    {
        "id": "2a2c3e6a022d6303",
        "type": "http response",
        "z": "e817c53a81aff0e0",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 830,
        "y": 280,
        "wires": []
    },
    {
        "id": "cc777a9dc8f4a1e9",
        "type": "http response",
        "z": "e817c53a81aff0e0",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 830,
        "y": 560,
        "wires": []
    },
    {
        "id": "1b2b8fe6ca68c834",
        "type": "mqtt in",
        "z": "e817c53a81aff0e0",
        "name": "MQTT from ESP32 (Lock)",
        "topic": "lock_status",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "83232c1e0408fa13",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 330,
        "y": 820,
        "wires": [
            [
                "1b24286e0782e1c2"
            ]
        ]
    },
    {
        "id": "6e8aecf9cd801850",
        "type": "influxdb out",
        "z": "e817c53a81aff0e0",
        "influxdb": "b99fd905dd34feb9",
        "name": "influx_authenticate_log",
        "measurement": "",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "docs",
        "bucket": "home",
        "x": 1620,
        "y": 760,
        "wires": []
    },
    {
        "id": "1b24286e0782e1c2",
        "type": "function",
        "z": "e817c53a81aff0e0",
        "name": "door_open_tracker",
        "func": "// 1. Handle incoming data (Parse if it's a string, use as-is if it's an object)\nlet data = msg.payload;\n\n// Safety check: sometimes MQTT nodes pass data as a JSON string, not an object.\nif (typeof data === 'string') {\n    try {\n        data = JSON.parse(data);\n    } catch (e) {\n        node.warn(\"Input was not valid JSON\");\n        return null;\n    }\n}\n\n// 2. Extract variables from the incoming JSON\n// Use specific names so we don't overwrite them later\nlet inputStatus = data.status ? data.status.toLowerCase() : \"\";\nlet inputDoorID = data.door_id;\n\n// 3. Validation: Stop if door_id is missing\nif (!inputDoorID) {\n    node.warn(\"Missing door_id in payload\");\n    return null;\n}\n\n// 4. Convert Status to Integer\nlet statusInt;\nif (inputStatus === \"locked\") {\n    statusInt = 1;\n} else if (inputStatus === \"unlocked\") {\n    statusInt = 0;\n} else {\n    node.warn(`Invalid status: ${inputStatus}`);\n    return null;\n}\n\n// 5. Construct the InfluxDB Message\nmsg.measurement = \"lock_status\";\nmsg.tags = {\n    door_id: inputDoorID\n};\nmsg.payload = {\n    status: statusInt\n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 820,
        "wires": [
            [
                "9e792afae5365b79"
            ]
        ]
    },
    {
        "id": "9e792afae5365b79",
        "type": "influxdb out",
        "z": "e817c53a81aff0e0",
        "influxdb": "b99fd905dd34feb9",
        "name": "influx_door_status",
        "measurement": "",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "docs",
        "bucket": "home",
        "x": 870,
        "y": 820,
        "wires": []
    },
    {
        "id": "815f1919bf16efd6",
        "type": "function",
        "z": "e817c53a81aff0e0",
        "name": "function 3",
        "func": "let data = msg.payload;\n\n// Parse if needed\nif (typeof data === \"string\") {\n    try {\n        data = JSON.parse(data);\n    } catch (e) {\n        node.warn(\"Invalid JSON payload\");\n        return null;\n    }\n}\n\n// Validate door_id\nif (!data.door_id) {\n    node.warn(\"Missing door_id\");\n    return null;\n}\n\n// Normalize action\nlet actionString;\n\nif (typeof data.action === \"number\") {\n    if (data.action === 1) actionString = \"lock\";\n    if (data.action === 0) actionString = \"unlock\";\n}\nelse if (typeof data.action === \"string\") {\n    if (data.action != \"unlock\" && data.action != \"lock\") {\n        node.warn(`Invalid action string: ${data.action}`);\n        return null;\n    }\n    actionString = data.action.toLowerCase();\n}\nelse {\n    node.warn(\"Missing or invalid action type\");\n    return null;\n}\n\n// Construct InfluxDB message\nmsg.measurement = \"authentication_log\";\nmsg.tags = {\n    door_id: data.door_id\n};\nmsg.payload = {\n    status: \"success\",\n    method: \"phone\",\n    action: actionString\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 760,
        "wires": [
            [
                "6e8aecf9cd801850"
            ]
        ]
    },
    {
        "id": "2148ddeb5795b2e7",
        "type": "function",
        "z": "e817c53a81aff0e0",
        "name": "function 4",
        "func": "// 1. Handle incoming data (Parse if it's a string, use as-is if it's an object)\nlet data = msg.payload;\n\n// Safety check: sometimes MQTT nodes pass data as a JSON string, not an object.\nif (typeof data === 'string') {\n    try {\n        data = JSON.parse(data);\n    } catch (e) {\n        node.warn(\"Input was not valid JSON\");\n        return null;\n    }\n}\n\n// 2. Extract variables from the incoming JSON\n// Use specific names so we don't overwrite them later\nlet inputAction = data.action ? data.action.toLowerCase() : \"\";\nlet inputDoorID = data.door_id;\n\n// 3. Validation: Stop if door_id is missing\nif (!inputDoorID) {\n    node.warn(\"Missing door_id in payload\");\n    return null;\n}\n\n// 4. Convert Status to Integer\nlet actionInt;\nif (inputAction === \"lock\") {\n    actionInt = 0;\n} else if (inputAction === \"unlock\") {\n    actionInt = 1;\n} else {\n    node.warn(`Invalid action: ${inputAction}`);\n    return null;\n}\n\nmsg.payload = {\n    action: actionInt\n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 840,
        "wires": [
            [
                "022d67b064290496"
            ]
        ]
    },
    {
        "id": "93b189199d614ac2",
        "type": "link in",
        "z": "e817c53a81aff0e0",
        "name": "link in 1",
        "links": [
            "b617697f6a501d22"
        ],
        "x": 1275,
        "y": 640,
        "wires": [
            [
                "815f1919bf16efd6",
                "2148ddeb5795b2e7"
            ]
        ]
    },
    {
        "id": "b617697f6a501d22",
        "type": "link out",
        "z": "e817c53a81aff0e0",
        "name": "link out 1",
        "mode": "link",
        "links": [
            "93b189199d614ac2"
        ],
        "x": 1125,
        "y": 640,
        "wires": []
    },
    {
        "id": "65aa63c4c9d72312",
        "type": "mqtt in",
        "z": "e817c53a81aff0e0",
        "name": "MQTT from ESP32 (Alert)",
        "topic": "alert",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "83232c1e0408fa13",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 330,
        "y": 960,
        "wires": [
            [
                "d6db4c337fdf84ea"
            ]
        ]
    },
    {
        "id": "d6db4c337fdf84ea",
        "type": "function",
        "z": "e817c53a81aff0e0",
        "name": "alert_handler",
        "func": "// 1. Handle incoming data (Parse if it's a string, use as-is if it's an object)\nlet data = msg.payload;\n\n// Safety check: sometimes MQTT nodes pass data as a JSON string, not an object.\nif (typeof data === 'string') {\n    try {\n        data = JSON.parse(data);\n    } catch (e) {\n        node.warn(\"Input was not valid JSON\");\n        return null;\n    }\n}\n\n// 2. Extract variables from the incoming JSON\n// Use specific names so we don't overwrite them later\nlet inputDoorID = data.door_id;\n\n// 3. Validation: Stop if door_id is missing\nif (!inputDoorID) {\n    node.warn(\"Missing door_id in payload\");\n    return null;\n}\n\n// 5. Construct the InfluxDB Message\nmsg.measurement = \"door_alert\";\nmsg.tags = {\n    door_id: inputDoorID\n};\nmsg.payload = {\n    message: data.message\n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 960,
        "wires": [
            [
                "75e2e117fb3fa826"
            ]
        ]
    },
    {
        "id": "75e2e117fb3fa826",
        "type": "influxdb out",
        "z": "e817c53a81aff0e0",
        "influxdb": "b99fd905dd34feb9",
        "name": "influx_door_status",
        "measurement": "",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "docs",
        "bucket": "home",
        "x": 850,
        "y": 960,
        "wires": []
    },
    {
        "id": "30cd0130d52a4520",
        "type": "mqtt in",
        "z": "e817c53a81aff0e0",
        "name": "MQTT from ESP32 (Authentication Log)",
        "topic": "authentication_log",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "83232c1e0408fa13",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 1290,
        "y": 520,
        "wires": [
            [
                "f4f4df1d6221b308"
            ]
        ]
    },
    {
        "id": "f4f4df1d6221b308",
        "type": "function",
        "z": "e817c53a81aff0e0",
        "name": "function 5",
        "func": "// 1. Handle incoming data (Parse if it's a string, use as-is if it's an object)\nlet data = msg.payload;\n\n// Safety check: sometimes MQTT nodes pass data as a JSON string, not an object.\nif (typeof data === 'string') {\n    try {\n        data = JSON.parse(data);\n    } catch (e) {\n        node.warn(\"Input was not valid JSON\");\n        return null;\n    }\n}\n\n// 2. Extract variables from the incoming JSON\n// Use specific names so we don't overwrite them later\nlet inputDoorID = data.door_id;\nlet inputStatus = data.status;\nlet inputMethod = data.method;\nlet inputAction = data.action;\n\n// 3. Validation: Stop if door_id is missing\nif (!inputDoorID) {\n    node.warn(\"Missing door_id in payload\");\n    return null;\n}\n// 5. Construct the InfluxDB Message\nmsg.measurement = \"authentication_log\";\nmsg.tags = {\n    door_id: inputDoorID\n};\nmsg.payload = {\n    status: data.status,\n    method: data.method,\n    action: data.action\n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1520,
        "y": 600,
        "wires": [
            [
                "6e8aecf9cd801850"
            ]
        ]
    },
    {
        "id": "83232c1e0408fa13",
        "type": "mqtt-broker",
        "name": "",
        "broker": "mosquitto",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "b99fd905dd34feb9",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "influxdb",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://influxdb2:8086",
        "timeout": 10,
        "rejectUnauthorized": false
    },
    {
        "id": "2fb28ba2d92cb66a",
        "type": "global-config",
        "env": [],
        "modules": {
            "node-red-contrib-influxdb": "0.7.0"
        }
    }
]